/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.flaptor.indextank.rpc;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

@SuppressWarnings("all") public class Storage {

  public interface Iface {

    public void enqueueAddStore(String indexId, String docId, Document document, int timestamp_boost, Map<Integer,Double> boosts) throws IndextankException, TException;

    public void enqueueRemoveStore(String indexId, String docId) throws IndextankException, TException;

    public void enqueueUpdateBoosts(String indexId, String docId, Map<Integer,Double> boosts) throws IndextankException, TException;

    public void enqueueUpdateTimestamp(String indexId, String docId, int timestamp_boost) throws IndextankException, TException;

    public void enqueueUpdateCategories(String indexId, String docId, Map<String,String> categories) throws IndextankException, TException;

    public String sendAdminCommand(String command, Map<String,String> info) throws IndextankException, TException;

  }

  public interface AsyncIface {

    public void enqueueAddStore(String indexId, String docId, Document document, int timestamp_boost, Map<Integer,Double> boosts, AsyncMethodCallback<AsyncClient.enqueueAddStore_call> resultHandler) throws TException;

    public void enqueueRemoveStore(String indexId, String docId, AsyncMethodCallback<AsyncClient.enqueueRemoveStore_call> resultHandler) throws TException;

    public void enqueueUpdateBoosts(String indexId, String docId, Map<Integer,Double> boosts, AsyncMethodCallback<AsyncClient.enqueueUpdateBoosts_call> resultHandler) throws TException;

    public void enqueueUpdateTimestamp(String indexId, String docId, int timestamp_boost, AsyncMethodCallback<AsyncClient.enqueueUpdateTimestamp_call> resultHandler) throws TException;

    public void enqueueUpdateCategories(String indexId, String docId, Map<String,String> categories, AsyncMethodCallback<AsyncClient.enqueueUpdateCategories_call> resultHandler) throws TException;

    public void sendAdminCommand(String command, Map<String,String> info, AsyncMethodCallback<AsyncClient.sendAdminCommand_call> resultHandler) throws TException;

  }

  public static class Client implements TServiceClient, Iface {
    public static class Factory implements TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(TProtocol iprot, TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void enqueueAddStore(String indexId, String docId, Document document, int timestamp_boost, Map<Integer,Double> boosts) throws IndextankException, TException
    {
      send_enqueueAddStore(indexId, docId, document, timestamp_boost, boosts);
      recv_enqueueAddStore();
    }

    public void send_enqueueAddStore(String indexId, String docId, Document document, int timestamp_boost, Map<Integer,Double> boosts) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("enqueueAddStore", TMessageType.CALL, ++seqid_));
      enqueueAddStore_args args = new enqueueAddStore_args();
      args.set_indexId(indexId);
      args.set_docId(docId);
      args.set_document(document);
      args.set_timestamp_boost(timestamp_boost);
      args.set_boosts(boosts);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_enqueueAddStore() throws IndextankException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "enqueueAddStore failed: out of sequence response");
      }
      enqueueAddStore_result result = new enqueueAddStore_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ite != null) {
        throw result.ite;
      }
      return;
    }

    public void enqueueRemoveStore(String indexId, String docId) throws IndextankException, TException
    {
      send_enqueueRemoveStore(indexId, docId);
      recv_enqueueRemoveStore();
    }

    public void send_enqueueRemoveStore(String indexId, String docId) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("enqueueRemoveStore", TMessageType.CALL, ++seqid_));
      enqueueRemoveStore_args args = new enqueueRemoveStore_args();
      args.set_indexId(indexId);
      args.set_docId(docId);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_enqueueRemoveStore() throws IndextankException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "enqueueRemoveStore failed: out of sequence response");
      }
      enqueueRemoveStore_result result = new enqueueRemoveStore_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ite != null) {
        throw result.ite;
      }
      return;
    }

    public void enqueueUpdateBoosts(String indexId, String docId, Map<Integer,Double> boosts) throws IndextankException, TException
    {
      send_enqueueUpdateBoosts(indexId, docId, boosts);
      recv_enqueueUpdateBoosts();
    }

    public void send_enqueueUpdateBoosts(String indexId, String docId, Map<Integer,Double> boosts) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("enqueueUpdateBoosts", TMessageType.CALL, ++seqid_));
      enqueueUpdateBoosts_args args = new enqueueUpdateBoosts_args();
      args.set_indexId(indexId);
      args.set_docId(docId);
      args.set_boosts(boosts);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_enqueueUpdateBoosts() throws IndextankException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "enqueueUpdateBoosts failed: out of sequence response");
      }
      enqueueUpdateBoosts_result result = new enqueueUpdateBoosts_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ite != null) {
        throw result.ite;
      }
      return;
    }

    public void enqueueUpdateTimestamp(String indexId, String docId, int timestamp_boost) throws IndextankException, TException
    {
      send_enqueueUpdateTimestamp(indexId, docId, timestamp_boost);
      recv_enqueueUpdateTimestamp();
    }

    public void send_enqueueUpdateTimestamp(String indexId, String docId, int timestamp_boost) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("enqueueUpdateTimestamp", TMessageType.CALL, ++seqid_));
      enqueueUpdateTimestamp_args args = new enqueueUpdateTimestamp_args();
      args.set_indexId(indexId);
      args.set_docId(docId);
      args.set_timestamp_boost(timestamp_boost);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_enqueueUpdateTimestamp() throws IndextankException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "enqueueUpdateTimestamp failed: out of sequence response");
      }
      enqueueUpdateTimestamp_result result = new enqueueUpdateTimestamp_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ite != null) {
        throw result.ite;
      }
      return;
    }

    public void enqueueUpdateCategories(String indexId, String docId, Map<String,String> categories) throws IndextankException, TException
    {
      send_enqueueUpdateCategories(indexId, docId, categories);
      recv_enqueueUpdateCategories();
    }

    public void send_enqueueUpdateCategories(String indexId, String docId, Map<String,String> categories) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("enqueueUpdateCategories", TMessageType.CALL, ++seqid_));
      enqueueUpdateCategories_args args = new enqueueUpdateCategories_args();
      args.set_indexId(indexId);
      args.set_docId(docId);
      args.set_categories(categories);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_enqueueUpdateCategories() throws IndextankException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "enqueueUpdateCategories failed: out of sequence response");
      }
      enqueueUpdateCategories_result result = new enqueueUpdateCategories_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ite != null) {
        throw result.ite;
      }
      return;
    }

    public String sendAdminCommand(String command, Map<String,String> info) throws IndextankException, TException
    {
      send_sendAdminCommand(command, info);
      return recv_sendAdminCommand();
    }

    public void send_sendAdminCommand(String command, Map<String,String> info) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("sendAdminCommand", TMessageType.CALL, ++seqid_));
      sendAdminCommand_args args = new sendAdminCommand_args();
      args.set_command(command);
      args.set_info(info);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_sendAdminCommand() throws IndextankException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "sendAdminCommand failed: out of sequence response");
      }
      sendAdminCommand_result result = new sendAdminCommand_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.is_set_success()) {
        return result.success;
      }
      if (result.ite != null) {
        throw result.ite;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "sendAdminCommand failed: unknown result");
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void enqueueAddStore(String indexId, String docId, Document document, int timestamp_boost, Map<Integer,Double> boosts, AsyncMethodCallback<enqueueAddStore_call> resultHandler) throws TException {
      checkReady();
      enqueueAddStore_call method_call = new enqueueAddStore_call(indexId, docId, document, timestamp_boost, boosts, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class enqueueAddStore_call extends TAsyncMethodCall {
      private String indexId;
      private String docId;
      private Document document;
      private int timestamp_boost;
      private Map<Integer,Double> boosts;
      public enqueueAddStore_call(String indexId, String docId, Document document, int timestamp_boost, Map<Integer,Double> boosts, AsyncMethodCallback<enqueueAddStore_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.indexId = indexId;
        this.docId = docId;
        this.document = document;
        this.timestamp_boost = timestamp_boost;
        this.boosts = boosts;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("enqueueAddStore", TMessageType.CALL, 0));
        enqueueAddStore_args args = new enqueueAddStore_args();
        args.set_indexId(indexId);
        args.set_docId(docId);
        args.set_document(document);
        args.set_timestamp_boost(timestamp_boost);
        args.set_boosts(boosts);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IndextankException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_enqueueAddStore();
      }
    }

    public void enqueueRemoveStore(String indexId, String docId, AsyncMethodCallback<enqueueRemoveStore_call> resultHandler) throws TException {
      checkReady();
      enqueueRemoveStore_call method_call = new enqueueRemoveStore_call(indexId, docId, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class enqueueRemoveStore_call extends TAsyncMethodCall {
      private String indexId;
      private String docId;
      public enqueueRemoveStore_call(String indexId, String docId, AsyncMethodCallback<enqueueRemoveStore_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.indexId = indexId;
        this.docId = docId;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("enqueueRemoveStore", TMessageType.CALL, 0));
        enqueueRemoveStore_args args = new enqueueRemoveStore_args();
        args.set_indexId(indexId);
        args.set_docId(docId);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IndextankException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_enqueueRemoveStore();
      }
    }

    public void enqueueUpdateBoosts(String indexId, String docId, Map<Integer,Double> boosts, AsyncMethodCallback<enqueueUpdateBoosts_call> resultHandler) throws TException {
      checkReady();
      enqueueUpdateBoosts_call method_call = new enqueueUpdateBoosts_call(indexId, docId, boosts, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class enqueueUpdateBoosts_call extends TAsyncMethodCall {
      private String indexId;
      private String docId;
      private Map<Integer,Double> boosts;
      public enqueueUpdateBoosts_call(String indexId, String docId, Map<Integer,Double> boosts, AsyncMethodCallback<enqueueUpdateBoosts_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.indexId = indexId;
        this.docId = docId;
        this.boosts = boosts;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("enqueueUpdateBoosts", TMessageType.CALL, 0));
        enqueueUpdateBoosts_args args = new enqueueUpdateBoosts_args();
        args.set_indexId(indexId);
        args.set_docId(docId);
        args.set_boosts(boosts);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IndextankException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_enqueueUpdateBoosts();
      }
    }

    public void enqueueUpdateTimestamp(String indexId, String docId, int timestamp_boost, AsyncMethodCallback<enqueueUpdateTimestamp_call> resultHandler) throws TException {
      checkReady();
      enqueueUpdateTimestamp_call method_call = new enqueueUpdateTimestamp_call(indexId, docId, timestamp_boost, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class enqueueUpdateTimestamp_call extends TAsyncMethodCall {
      private String indexId;
      private String docId;
      private int timestamp_boost;
      public enqueueUpdateTimestamp_call(String indexId, String docId, int timestamp_boost, AsyncMethodCallback<enqueueUpdateTimestamp_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.indexId = indexId;
        this.docId = docId;
        this.timestamp_boost = timestamp_boost;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("enqueueUpdateTimestamp", TMessageType.CALL, 0));
        enqueueUpdateTimestamp_args args = new enqueueUpdateTimestamp_args();
        args.set_indexId(indexId);
        args.set_docId(docId);
        args.set_timestamp_boost(timestamp_boost);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IndextankException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_enqueueUpdateTimestamp();
      }
    }

    public void enqueueUpdateCategories(String indexId, String docId, Map<String,String> categories, AsyncMethodCallback<enqueueUpdateCategories_call> resultHandler) throws TException {
      checkReady();
      enqueueUpdateCategories_call method_call = new enqueueUpdateCategories_call(indexId, docId, categories, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class enqueueUpdateCategories_call extends TAsyncMethodCall {
      private String indexId;
      private String docId;
      private Map<String,String> categories;
      public enqueueUpdateCategories_call(String indexId, String docId, Map<String,String> categories, AsyncMethodCallback<enqueueUpdateCategories_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.indexId = indexId;
        this.docId = docId;
        this.categories = categories;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("enqueueUpdateCategories", TMessageType.CALL, 0));
        enqueueUpdateCategories_args args = new enqueueUpdateCategories_args();
        args.set_indexId(indexId);
        args.set_docId(docId);
        args.set_categories(categories);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws IndextankException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_enqueueUpdateCategories();
      }
    }

    public void sendAdminCommand(String command, Map<String,String> info, AsyncMethodCallback<sendAdminCommand_call> resultHandler) throws TException {
      checkReady();
      sendAdminCommand_call method_call = new sendAdminCommand_call(command, info, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class sendAdminCommand_call extends TAsyncMethodCall {
      private String command;
      private Map<String,String> info;
      public sendAdminCommand_call(String command, Map<String,String> info, AsyncMethodCallback<sendAdminCommand_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.command = command;
        this.info = info;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("sendAdminCommand", TMessageType.CALL, 0));
        sendAdminCommand_args args = new sendAdminCommand_args();
        args.set_command(command);
        args.set_info(info);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws IndextankException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_sendAdminCommand();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("enqueueAddStore", new enqueueAddStore());
      processMap_.put("enqueueRemoveStore", new enqueueRemoveStore());
      processMap_.put("enqueueUpdateBoosts", new enqueueUpdateBoosts());
      processMap_.put("enqueueUpdateTimestamp", new enqueueUpdateTimestamp());
      processMap_.put("enqueueUpdateCategories", new enqueueUpdateCategories());
      processMap_.put("sendAdminCommand", new sendAdminCommand());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class enqueueAddStore implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        enqueueAddStore_args args = new enqueueAddStore_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("enqueueAddStore", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        enqueueAddStore_result result = new enqueueAddStore_result();
        try {
          iface_.enqueueAddStore(args.indexId, args.docId, args.document, args.timestamp_boost, args.boosts);
        } catch (IndextankException ite) {
          result.ite = ite;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing enqueueAddStore", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing enqueueAddStore");
          oprot.writeMessageBegin(new TMessage("enqueueAddStore", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("enqueueAddStore", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class enqueueRemoveStore implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        enqueueRemoveStore_args args = new enqueueRemoveStore_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("enqueueRemoveStore", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        enqueueRemoveStore_result result = new enqueueRemoveStore_result();
        try {
          iface_.enqueueRemoveStore(args.indexId, args.docId);
        } catch (IndextankException ite) {
          result.ite = ite;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing enqueueRemoveStore", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing enqueueRemoveStore");
          oprot.writeMessageBegin(new TMessage("enqueueRemoveStore", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("enqueueRemoveStore", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class enqueueUpdateBoosts implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        enqueueUpdateBoosts_args args = new enqueueUpdateBoosts_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("enqueueUpdateBoosts", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        enqueueUpdateBoosts_result result = new enqueueUpdateBoosts_result();
        try {
          iface_.enqueueUpdateBoosts(args.indexId, args.docId, args.boosts);
        } catch (IndextankException ite) {
          result.ite = ite;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing enqueueUpdateBoosts", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing enqueueUpdateBoosts");
          oprot.writeMessageBegin(new TMessage("enqueueUpdateBoosts", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("enqueueUpdateBoosts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class enqueueUpdateTimestamp implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        enqueueUpdateTimestamp_args args = new enqueueUpdateTimestamp_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("enqueueUpdateTimestamp", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        enqueueUpdateTimestamp_result result = new enqueueUpdateTimestamp_result();
        try {
          iface_.enqueueUpdateTimestamp(args.indexId, args.docId, args.timestamp_boost);
        } catch (IndextankException ite) {
          result.ite = ite;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing enqueueUpdateTimestamp", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing enqueueUpdateTimestamp");
          oprot.writeMessageBegin(new TMessage("enqueueUpdateTimestamp", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("enqueueUpdateTimestamp", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class enqueueUpdateCategories implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        enqueueUpdateCategories_args args = new enqueueUpdateCategories_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("enqueueUpdateCategories", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        enqueueUpdateCategories_result result = new enqueueUpdateCategories_result();
        try {
          iface_.enqueueUpdateCategories(args.indexId, args.docId, args.categories);
        } catch (IndextankException ite) {
          result.ite = ite;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing enqueueUpdateCategories", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing enqueueUpdateCategories");
          oprot.writeMessageBegin(new TMessage("enqueueUpdateCategories", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("enqueueUpdateCategories", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class sendAdminCommand implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        sendAdminCommand_args args = new sendAdminCommand_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("sendAdminCommand", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        sendAdminCommand_result result = new sendAdminCommand_result();
        try {
          result.success = iface_.sendAdminCommand(args.command, args.info);
        } catch (IndextankException ite) {
          result.ite = ite;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing sendAdminCommand", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing sendAdminCommand");
          oprot.writeMessageBegin(new TMessage("sendAdminCommand", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("sendAdminCommand", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class enqueueAddStore_args implements TBase<enqueueAddStore_args, enqueueAddStore_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enqueueAddStore_args");

    private static final TField INDEX_ID_FIELD_DESC = new TField("indexId", TType.STRING, (short)1);
    private static final TField DOC_ID_FIELD_DESC = new TField("docId", TType.STRING, (short)2);
    private static final TField DOCUMENT_FIELD_DESC = new TField("document", TType.STRUCT, (short)3);
    private static final TField TIMESTAMP_BOOST_FIELD_DESC = new TField("timestamp_boost", TType.I32, (short)4);
    private static final TField BOOSTS_FIELD_DESC = new TField("boosts", TType.MAP, (short)5);

    private String indexId;
    private String docId;
    private Document document;
    private int timestamp_boost;
    private Map<Integer,Double> boosts;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      INDEX_ID((short)1, "indexId"),
      DOC_ID((short)2, "docId"),
      DOCUMENT((short)3, "document"),
      TIMESTAMP_BOOST((short)4, "timestamp_boost"),
      BOOSTS((short)5, "boosts");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // INDEX_ID
            return INDEX_ID;
          case 2: // DOC_ID
            return DOC_ID;
          case 3: // DOCUMENT
            return DOCUMENT;
          case 4: // TIMESTAMP_BOOST
            return TIMESTAMP_BOOST;
          case 5: // BOOSTS
            return BOOSTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_BOOST_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.INDEX_ID, new FieldMetaData("indexId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DOC_ID, new FieldMetaData("docId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DOCUMENT, new FieldMetaData("document", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Document.class)));
      tmpMap.put(_Fields.TIMESTAMP_BOOST, new FieldMetaData("timestamp_boost", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      tmpMap.put(_Fields.BOOSTS, new FieldMetaData("boosts", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.I32), 
              new FieldValueMetaData(TType.DOUBLE))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enqueueAddStore_args.class, metaDataMap);
    }

    public enqueueAddStore_args() {
    }

    public enqueueAddStore_args(
      String indexId,
      String docId,
      Document document,
      int timestamp_boost,
      Map<Integer,Double> boosts)
    {
      this();
      this.indexId = indexId;
      this.docId = docId;
      this.document = document;
      this.timestamp_boost = timestamp_boost;
      set_timestamp_boost_isSet(true);
      this.boosts = boosts;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enqueueAddStore_args(enqueueAddStore_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.is_set_indexId()) {
        this.indexId = other.indexId;
      }
      if (other.is_set_docId()) {
        this.docId = other.docId;
      }
      if (other.is_set_document()) {
        this.document = new Document(other.document);
      }
      this.timestamp_boost = other.timestamp_boost;
      if (other.is_set_boosts()) {
        Map<Integer,Double> __this__boosts = new HashMap<Integer,Double>();
        for (Map.Entry<Integer, Double> other_element : other.boosts.entrySet()) {

          Integer other_element_key = other_element.getKey();
          Double other_element_value = other_element.getValue();

          Integer __this__boosts_copy_key = other_element_key;

          Double __this__boosts_copy_value = other_element_value;

          __this__boosts.put(__this__boosts_copy_key, __this__boosts_copy_value);
        }
        this.boosts = __this__boosts;
      }
    }

    public enqueueAddStore_args deepCopy() {
      return new enqueueAddStore_args(this);
    }

    @Override
    public void clear() {
      this.indexId = null;
      this.docId = null;
      this.document = null;
      set_timestamp_boost_isSet(false);
      this.timestamp_boost = 0;
      this.boosts = null;
    }

    public String get_indexId() {
      return this.indexId;
    }

    public enqueueAddStore_args set_indexId(String indexId) {
      this.indexId = indexId;
      return this;
    }

    public void unset_indexId() {
      this.indexId = null;
    }

    /** Returns true if field indexId is set (has been asigned a value) and false otherwise */
    public boolean is_set_indexId() {
      return this.indexId != null;
    }

    public void set_indexId_isSet(boolean value) {
      if (!value) {
        this.indexId = null;
      }
    }

    public String get_docId() {
      return this.docId;
    }

    public enqueueAddStore_args set_docId(String docId) {
      this.docId = docId;
      return this;
    }

    public void unset_docId() {
      this.docId = null;
    }

    /** Returns true if field docId is set (has been asigned a value) and false otherwise */
    public boolean is_set_docId() {
      return this.docId != null;
    }

    public void set_docId_isSet(boolean value) {
      if (!value) {
        this.docId = null;
      }
    }

    public Document get_document() {
      return this.document;
    }

    public enqueueAddStore_args set_document(Document document) {
      this.document = document;
      return this;
    }

    public void unset_document() {
      this.document = null;
    }

    /** Returns true if field document is set (has been asigned a value) and false otherwise */
    public boolean is_set_document() {
      return this.document != null;
    }

    public void set_document_isSet(boolean value) {
      if (!value) {
        this.document = null;
      }
    }

    public int get_timestamp_boost() {
      return this.timestamp_boost;
    }

    public enqueueAddStore_args set_timestamp_boost(int timestamp_boost) {
      this.timestamp_boost = timestamp_boost;
      set_timestamp_boost_isSet(true);
      return this;
    }

    public void unset_timestamp_boost() {
      __isset_bit_vector.clear(__TIMESTAMP_BOOST_ISSET_ID);
    }

    /** Returns true if field timestamp_boost is set (has been asigned a value) and false otherwise */
    public boolean is_set_timestamp_boost() {
      return __isset_bit_vector.get(__TIMESTAMP_BOOST_ISSET_ID);
    }

    public void set_timestamp_boost_isSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_BOOST_ISSET_ID, value);
    }

    public int get_boosts_size() {
      return (this.boosts == null) ? 0 : this.boosts.size();
    }

    public void put_to_boosts(int key, double val) {
      if (this.boosts == null) {
        this.boosts = new HashMap<Integer,Double>();
      }
      this.boosts.put(key, val);
    }

    public Map<Integer,Double> get_boosts() {
      return this.boosts;
    }

    public enqueueAddStore_args set_boosts(Map<Integer,Double> boosts) {
      this.boosts = boosts;
      return this;
    }

    public void unset_boosts() {
      this.boosts = null;
    }

    /** Returns true if field boosts is set (has been asigned a value) and false otherwise */
    public boolean is_set_boosts() {
      return this.boosts != null;
    }

    public void set_boosts_isSet(boolean value) {
      if (!value) {
        this.boosts = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case INDEX_ID:
        if (value == null) {
          unset_indexId();
        } else {
          set_indexId((String)value);
        }
        break;

      case DOC_ID:
        if (value == null) {
          unset_docId();
        } else {
          set_docId((String)value);
        }
        break;

      case DOCUMENT:
        if (value == null) {
          unset_document();
        } else {
          set_document((Document)value);
        }
        break;

      case TIMESTAMP_BOOST:
        if (value == null) {
          unset_timestamp_boost();
        } else {
          set_timestamp_boost((Integer)value);
        }
        break;

      case BOOSTS:
        if (value == null) {
          unset_boosts();
        } else {
          set_boosts((Map<Integer,Double>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case INDEX_ID:
        return get_indexId();

      case DOC_ID:
        return get_docId();

      case DOCUMENT:
        return get_document();

      case TIMESTAMP_BOOST:
        return new Integer(get_timestamp_boost());

      case BOOSTS:
        return get_boosts();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case INDEX_ID:
        return is_set_indexId();
      case DOC_ID:
        return is_set_docId();
      case DOCUMENT:
        return is_set_document();
      case TIMESTAMP_BOOST:
        return is_set_timestamp_boost();
      case BOOSTS:
        return is_set_boosts();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enqueueAddStore_args)
        return this.equals((enqueueAddStore_args)that);
      return false;
    }

    public boolean equals(enqueueAddStore_args that) {
      if (that == null)
        return false;

      boolean this_present_indexId = true && this.is_set_indexId();
      boolean that_present_indexId = true && that.is_set_indexId();
      if (this_present_indexId || that_present_indexId) {
        if (!(this_present_indexId && that_present_indexId))
          return false;
        if (!this.indexId.equals(that.indexId))
          return false;
      }

      boolean this_present_docId = true && this.is_set_docId();
      boolean that_present_docId = true && that.is_set_docId();
      if (this_present_docId || that_present_docId) {
        if (!(this_present_docId && that_present_docId))
          return false;
        if (!this.docId.equals(that.docId))
          return false;
      }

      boolean this_present_document = true && this.is_set_document();
      boolean that_present_document = true && that.is_set_document();
      if (this_present_document || that_present_document) {
        if (!(this_present_document && that_present_document))
          return false;
        if (!this.document.equals(that.document))
          return false;
      }

      boolean this_present_timestamp_boost = true;
      boolean that_present_timestamp_boost = true;
      if (this_present_timestamp_boost || that_present_timestamp_boost) {
        if (!(this_present_timestamp_boost && that_present_timestamp_boost))
          return false;
        if (this.timestamp_boost != that.timestamp_boost)
          return false;
      }

      boolean this_present_boosts = true && this.is_set_boosts();
      boolean that_present_boosts = true && that.is_set_boosts();
      if (this_present_boosts || that_present_boosts) {
        if (!(this_present_boosts && that_present_boosts))
          return false;
        if (!this.boosts.equals(that.boosts))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enqueueAddStore_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enqueueAddStore_args typedOther = (enqueueAddStore_args)other;

      lastComparison = Boolean.valueOf(is_set_indexId()).compareTo(typedOther.is_set_indexId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_indexId()) {
        lastComparison = TBaseHelper.compareTo(this.indexId, typedOther.indexId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_docId()).compareTo(typedOther.is_set_docId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_docId()) {
        lastComparison = TBaseHelper.compareTo(this.docId, typedOther.docId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_document()).compareTo(typedOther.is_set_document());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_document()) {
        lastComparison = TBaseHelper.compareTo(this.document, typedOther.document);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_timestamp_boost()).compareTo(typedOther.is_set_timestamp_boost());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_timestamp_boost()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp_boost, typedOther.timestamp_boost);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_boosts()).compareTo(typedOther.is_set_boosts());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_boosts()) {
        lastComparison = TBaseHelper.compareTo(this.boosts, typedOther.boosts);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // INDEX_ID
            if (field.type == TType.STRING) {
              this.indexId = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // DOC_ID
            if (field.type == TType.STRING) {
              this.docId = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // DOCUMENT
            if (field.type == TType.STRUCT) {
              this.document = new Document();
              this.document.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // TIMESTAMP_BOOST
            if (field.type == TType.I32) {
              this.timestamp_boost = iprot.readI32();
              set_timestamp_boost_isSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 5: // BOOSTS
            if (field.type == TType.MAP) {
              {
                TMap _map145 = iprot.readMapBegin();
                this.boosts = new HashMap<Integer,Double>(2*_map145.size);
                for (int _i146 = 0; _i146 < _map145.size; ++_i146)
                {
                  int _key147;
                  double _val148;
                  _key147 = iprot.readI32();
                  _val148 = iprot.readDouble();
                  this.boosts.put(_key147, _val148);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.indexId != null) {
        oprot.writeFieldBegin(INDEX_ID_FIELD_DESC);
        oprot.writeString(this.indexId);
        oprot.writeFieldEnd();
      }
      if (this.docId != null) {
        oprot.writeFieldBegin(DOC_ID_FIELD_DESC);
        oprot.writeString(this.docId);
        oprot.writeFieldEnd();
      }
      if (this.document != null) {
        oprot.writeFieldBegin(DOCUMENT_FIELD_DESC);
        this.document.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_BOOST_FIELD_DESC);
      oprot.writeI32(this.timestamp_boost);
      oprot.writeFieldEnd();
      if (this.boosts != null) {
        oprot.writeFieldBegin(BOOSTS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.I32, TType.DOUBLE, this.boosts.size()));
          for (Map.Entry<Integer, Double> _iter149 : this.boosts.entrySet())
          {
            oprot.writeI32(_iter149.getKey());
            oprot.writeDouble(_iter149.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enqueueAddStore_args(");
      boolean first = true;

      sb.append("indexId:");
      if (this.indexId == null) {
        sb.append("null");
      } else {
        sb.append(this.indexId);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("docId:");
      if (this.docId == null) {
        sb.append("null");
      } else {
        sb.append(this.docId);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("document:");
      if (this.document == null) {
        sb.append("null");
      } else {
        sb.append(this.document);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp_boost:");
      sb.append(this.timestamp_boost);
      first = false;
      if (!first) sb.append(", ");
      sb.append("boosts:");
      if (this.boosts == null) {
        sb.append("null");
      } else {
        sb.append(this.boosts);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class enqueueAddStore_result implements TBase<enqueueAddStore_result, enqueueAddStore_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enqueueAddStore_result");

    private static final TField ITE_FIELD_DESC = new TField("ite", TType.STRUCT, (short)1);

    private IndextankException ite;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      ITE((short)1, "ite");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // ITE
            return ITE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.ITE, new FieldMetaData("ite", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enqueueAddStore_result.class, metaDataMap);
    }

    public enqueueAddStore_result() {
    }

    public enqueueAddStore_result(
      IndextankException ite)
    {
      this();
      this.ite = ite;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enqueueAddStore_result(enqueueAddStore_result other) {
      if (other.is_set_ite()) {
        this.ite = new IndextankException(other.ite);
      }
    }

    public enqueueAddStore_result deepCopy() {
      return new enqueueAddStore_result(this);
    }

    @Override
    public void clear() {
      this.ite = null;
    }

    public IndextankException get_ite() {
      return this.ite;
    }

    public enqueueAddStore_result set_ite(IndextankException ite) {
      this.ite = ite;
      return this;
    }

    public void unset_ite() {
      this.ite = null;
    }

    /** Returns true if field ite is set (has been asigned a value) and false otherwise */
    public boolean is_set_ite() {
      return this.ite != null;
    }

    public void set_ite_isSet(boolean value) {
      if (!value) {
        this.ite = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ITE:
        if (value == null) {
          unset_ite();
        } else {
          set_ite((IndextankException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ITE:
        return get_ite();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case ITE:
        return is_set_ite();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enqueueAddStore_result)
        return this.equals((enqueueAddStore_result)that);
      return false;
    }

    public boolean equals(enqueueAddStore_result that) {
      if (that == null)
        return false;

      boolean this_present_ite = true && this.is_set_ite();
      boolean that_present_ite = true && that.is_set_ite();
      if (this_present_ite || that_present_ite) {
        if (!(this_present_ite && that_present_ite))
          return false;
        if (!this.ite.equals(that.ite))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enqueueAddStore_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enqueueAddStore_result typedOther = (enqueueAddStore_result)other;

      lastComparison = Boolean.valueOf(is_set_ite()).compareTo(typedOther.is_set_ite());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_ite()) {
        lastComparison = TBaseHelper.compareTo(this.ite, typedOther.ite);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // ITE
            if (field.type == TType.STRUCT) {
              this.ite = new IndextankException();
              this.ite.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_ite()) {
        oprot.writeFieldBegin(ITE_FIELD_DESC);
        this.ite.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enqueueAddStore_result(");
      boolean first = true;

      sb.append("ite:");
      if (this.ite == null) {
        sb.append("null");
      } else {
        sb.append(this.ite);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class enqueueRemoveStore_args implements TBase<enqueueRemoveStore_args, enqueueRemoveStore_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enqueueRemoveStore_args");

    private static final TField INDEX_ID_FIELD_DESC = new TField("indexId", TType.STRING, (short)1);
    private static final TField DOC_ID_FIELD_DESC = new TField("docId", TType.STRING, (short)2);

    private String indexId;
    private String docId;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      INDEX_ID((short)1, "indexId"),
      DOC_ID((short)2, "docId");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // INDEX_ID
            return INDEX_ID;
          case 2: // DOC_ID
            return DOC_ID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.INDEX_ID, new FieldMetaData("indexId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DOC_ID, new FieldMetaData("docId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enqueueRemoveStore_args.class, metaDataMap);
    }

    public enqueueRemoveStore_args() {
    }

    public enqueueRemoveStore_args(
      String indexId,
      String docId)
    {
      this();
      this.indexId = indexId;
      this.docId = docId;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enqueueRemoveStore_args(enqueueRemoveStore_args other) {
      if (other.is_set_indexId()) {
        this.indexId = other.indexId;
      }
      if (other.is_set_docId()) {
        this.docId = other.docId;
      }
    }

    public enqueueRemoveStore_args deepCopy() {
      return new enqueueRemoveStore_args(this);
    }

    @Override
    public void clear() {
      this.indexId = null;
      this.docId = null;
    }

    public String get_indexId() {
      return this.indexId;
    }

    public enqueueRemoveStore_args set_indexId(String indexId) {
      this.indexId = indexId;
      return this;
    }

    public void unset_indexId() {
      this.indexId = null;
    }

    /** Returns true if field indexId is set (has been asigned a value) and false otherwise */
    public boolean is_set_indexId() {
      return this.indexId != null;
    }

    public void set_indexId_isSet(boolean value) {
      if (!value) {
        this.indexId = null;
      }
    }

    public String get_docId() {
      return this.docId;
    }

    public enqueueRemoveStore_args set_docId(String docId) {
      this.docId = docId;
      return this;
    }

    public void unset_docId() {
      this.docId = null;
    }

    /** Returns true if field docId is set (has been asigned a value) and false otherwise */
    public boolean is_set_docId() {
      return this.docId != null;
    }

    public void set_docId_isSet(boolean value) {
      if (!value) {
        this.docId = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case INDEX_ID:
        if (value == null) {
          unset_indexId();
        } else {
          set_indexId((String)value);
        }
        break;

      case DOC_ID:
        if (value == null) {
          unset_docId();
        } else {
          set_docId((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case INDEX_ID:
        return get_indexId();

      case DOC_ID:
        return get_docId();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case INDEX_ID:
        return is_set_indexId();
      case DOC_ID:
        return is_set_docId();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enqueueRemoveStore_args)
        return this.equals((enqueueRemoveStore_args)that);
      return false;
    }

    public boolean equals(enqueueRemoveStore_args that) {
      if (that == null)
        return false;

      boolean this_present_indexId = true && this.is_set_indexId();
      boolean that_present_indexId = true && that.is_set_indexId();
      if (this_present_indexId || that_present_indexId) {
        if (!(this_present_indexId && that_present_indexId))
          return false;
        if (!this.indexId.equals(that.indexId))
          return false;
      }

      boolean this_present_docId = true && this.is_set_docId();
      boolean that_present_docId = true && that.is_set_docId();
      if (this_present_docId || that_present_docId) {
        if (!(this_present_docId && that_present_docId))
          return false;
        if (!this.docId.equals(that.docId))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enqueueRemoveStore_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enqueueRemoveStore_args typedOther = (enqueueRemoveStore_args)other;

      lastComparison = Boolean.valueOf(is_set_indexId()).compareTo(typedOther.is_set_indexId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_indexId()) {
        lastComparison = TBaseHelper.compareTo(this.indexId, typedOther.indexId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_docId()).compareTo(typedOther.is_set_docId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_docId()) {
        lastComparison = TBaseHelper.compareTo(this.docId, typedOther.docId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // INDEX_ID
            if (field.type == TType.STRING) {
              this.indexId = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // DOC_ID
            if (field.type == TType.STRING) {
              this.docId = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.indexId != null) {
        oprot.writeFieldBegin(INDEX_ID_FIELD_DESC);
        oprot.writeString(this.indexId);
        oprot.writeFieldEnd();
      }
      if (this.docId != null) {
        oprot.writeFieldBegin(DOC_ID_FIELD_DESC);
        oprot.writeString(this.docId);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enqueueRemoveStore_args(");
      boolean first = true;

      sb.append("indexId:");
      if (this.indexId == null) {
        sb.append("null");
      } else {
        sb.append(this.indexId);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("docId:");
      if (this.docId == null) {
        sb.append("null");
      } else {
        sb.append(this.docId);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class enqueueRemoveStore_result implements TBase<enqueueRemoveStore_result, enqueueRemoveStore_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enqueueRemoveStore_result");

    private static final TField ITE_FIELD_DESC = new TField("ite", TType.STRUCT, (short)1);

    private IndextankException ite;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      ITE((short)1, "ite");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // ITE
            return ITE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.ITE, new FieldMetaData("ite", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enqueueRemoveStore_result.class, metaDataMap);
    }

    public enqueueRemoveStore_result() {
    }

    public enqueueRemoveStore_result(
      IndextankException ite)
    {
      this();
      this.ite = ite;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enqueueRemoveStore_result(enqueueRemoveStore_result other) {
      if (other.is_set_ite()) {
        this.ite = new IndextankException(other.ite);
      }
    }

    public enqueueRemoveStore_result deepCopy() {
      return new enqueueRemoveStore_result(this);
    }

    @Override
    public void clear() {
      this.ite = null;
    }

    public IndextankException get_ite() {
      return this.ite;
    }

    public enqueueRemoveStore_result set_ite(IndextankException ite) {
      this.ite = ite;
      return this;
    }

    public void unset_ite() {
      this.ite = null;
    }

    /** Returns true if field ite is set (has been asigned a value) and false otherwise */
    public boolean is_set_ite() {
      return this.ite != null;
    }

    public void set_ite_isSet(boolean value) {
      if (!value) {
        this.ite = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ITE:
        if (value == null) {
          unset_ite();
        } else {
          set_ite((IndextankException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ITE:
        return get_ite();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case ITE:
        return is_set_ite();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enqueueRemoveStore_result)
        return this.equals((enqueueRemoveStore_result)that);
      return false;
    }

    public boolean equals(enqueueRemoveStore_result that) {
      if (that == null)
        return false;

      boolean this_present_ite = true && this.is_set_ite();
      boolean that_present_ite = true && that.is_set_ite();
      if (this_present_ite || that_present_ite) {
        if (!(this_present_ite && that_present_ite))
          return false;
        if (!this.ite.equals(that.ite))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enqueueRemoveStore_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enqueueRemoveStore_result typedOther = (enqueueRemoveStore_result)other;

      lastComparison = Boolean.valueOf(is_set_ite()).compareTo(typedOther.is_set_ite());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_ite()) {
        lastComparison = TBaseHelper.compareTo(this.ite, typedOther.ite);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // ITE
            if (field.type == TType.STRUCT) {
              this.ite = new IndextankException();
              this.ite.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_ite()) {
        oprot.writeFieldBegin(ITE_FIELD_DESC);
        this.ite.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enqueueRemoveStore_result(");
      boolean first = true;

      sb.append("ite:");
      if (this.ite == null) {
        sb.append("null");
      } else {
        sb.append(this.ite);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class enqueueUpdateBoosts_args implements TBase<enqueueUpdateBoosts_args, enqueueUpdateBoosts_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enqueueUpdateBoosts_args");

    private static final TField INDEX_ID_FIELD_DESC = new TField("indexId", TType.STRING, (short)1);
    private static final TField DOC_ID_FIELD_DESC = new TField("docId", TType.STRING, (short)2);
    private static final TField BOOSTS_FIELD_DESC = new TField("boosts", TType.MAP, (short)3);

    private String indexId;
    private String docId;
    private Map<Integer,Double> boosts;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      INDEX_ID((short)1, "indexId"),
      DOC_ID((short)2, "docId"),
      BOOSTS((short)3, "boosts");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // INDEX_ID
            return INDEX_ID;
          case 2: // DOC_ID
            return DOC_ID;
          case 3: // BOOSTS
            return BOOSTS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.INDEX_ID, new FieldMetaData("indexId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DOC_ID, new FieldMetaData("docId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.BOOSTS, new FieldMetaData("boosts", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.I32), 
              new FieldValueMetaData(TType.DOUBLE))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enqueueUpdateBoosts_args.class, metaDataMap);
    }

    public enqueueUpdateBoosts_args() {
    }

    public enqueueUpdateBoosts_args(
      String indexId,
      String docId,
      Map<Integer,Double> boosts)
    {
      this();
      this.indexId = indexId;
      this.docId = docId;
      this.boosts = boosts;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enqueueUpdateBoosts_args(enqueueUpdateBoosts_args other) {
      if (other.is_set_indexId()) {
        this.indexId = other.indexId;
      }
      if (other.is_set_docId()) {
        this.docId = other.docId;
      }
      if (other.is_set_boosts()) {
        Map<Integer,Double> __this__boosts = new HashMap<Integer,Double>();
        for (Map.Entry<Integer, Double> other_element : other.boosts.entrySet()) {

          Integer other_element_key = other_element.getKey();
          Double other_element_value = other_element.getValue();

          Integer __this__boosts_copy_key = other_element_key;

          Double __this__boosts_copy_value = other_element_value;

          __this__boosts.put(__this__boosts_copy_key, __this__boosts_copy_value);
        }
        this.boosts = __this__boosts;
      }
    }

    public enqueueUpdateBoosts_args deepCopy() {
      return new enqueueUpdateBoosts_args(this);
    }

    @Override
    public void clear() {
      this.indexId = null;
      this.docId = null;
      this.boosts = null;
    }

    public String get_indexId() {
      return this.indexId;
    }

    public enqueueUpdateBoosts_args set_indexId(String indexId) {
      this.indexId = indexId;
      return this;
    }

    public void unset_indexId() {
      this.indexId = null;
    }

    /** Returns true if field indexId is set (has been asigned a value) and false otherwise */
    public boolean is_set_indexId() {
      return this.indexId != null;
    }

    public void set_indexId_isSet(boolean value) {
      if (!value) {
        this.indexId = null;
      }
    }

    public String get_docId() {
      return this.docId;
    }

    public enqueueUpdateBoosts_args set_docId(String docId) {
      this.docId = docId;
      return this;
    }

    public void unset_docId() {
      this.docId = null;
    }

    /** Returns true if field docId is set (has been asigned a value) and false otherwise */
    public boolean is_set_docId() {
      return this.docId != null;
    }

    public void set_docId_isSet(boolean value) {
      if (!value) {
        this.docId = null;
      }
    }

    public int get_boosts_size() {
      return (this.boosts == null) ? 0 : this.boosts.size();
    }

    public void put_to_boosts(int key, double val) {
      if (this.boosts == null) {
        this.boosts = new HashMap<Integer,Double>();
      }
      this.boosts.put(key, val);
    }

    public Map<Integer,Double> get_boosts() {
      return this.boosts;
    }

    public enqueueUpdateBoosts_args set_boosts(Map<Integer,Double> boosts) {
      this.boosts = boosts;
      return this;
    }

    public void unset_boosts() {
      this.boosts = null;
    }

    /** Returns true if field boosts is set (has been asigned a value) and false otherwise */
    public boolean is_set_boosts() {
      return this.boosts != null;
    }

    public void set_boosts_isSet(boolean value) {
      if (!value) {
        this.boosts = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case INDEX_ID:
        if (value == null) {
          unset_indexId();
        } else {
          set_indexId((String)value);
        }
        break;

      case DOC_ID:
        if (value == null) {
          unset_docId();
        } else {
          set_docId((String)value);
        }
        break;

      case BOOSTS:
        if (value == null) {
          unset_boosts();
        } else {
          set_boosts((Map<Integer,Double>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case INDEX_ID:
        return get_indexId();

      case DOC_ID:
        return get_docId();

      case BOOSTS:
        return get_boosts();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case INDEX_ID:
        return is_set_indexId();
      case DOC_ID:
        return is_set_docId();
      case BOOSTS:
        return is_set_boosts();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enqueueUpdateBoosts_args)
        return this.equals((enqueueUpdateBoosts_args)that);
      return false;
    }

    public boolean equals(enqueueUpdateBoosts_args that) {
      if (that == null)
        return false;

      boolean this_present_indexId = true && this.is_set_indexId();
      boolean that_present_indexId = true && that.is_set_indexId();
      if (this_present_indexId || that_present_indexId) {
        if (!(this_present_indexId && that_present_indexId))
          return false;
        if (!this.indexId.equals(that.indexId))
          return false;
      }

      boolean this_present_docId = true && this.is_set_docId();
      boolean that_present_docId = true && that.is_set_docId();
      if (this_present_docId || that_present_docId) {
        if (!(this_present_docId && that_present_docId))
          return false;
        if (!this.docId.equals(that.docId))
          return false;
      }

      boolean this_present_boosts = true && this.is_set_boosts();
      boolean that_present_boosts = true && that.is_set_boosts();
      if (this_present_boosts || that_present_boosts) {
        if (!(this_present_boosts && that_present_boosts))
          return false;
        if (!this.boosts.equals(that.boosts))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enqueueUpdateBoosts_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enqueueUpdateBoosts_args typedOther = (enqueueUpdateBoosts_args)other;

      lastComparison = Boolean.valueOf(is_set_indexId()).compareTo(typedOther.is_set_indexId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_indexId()) {
        lastComparison = TBaseHelper.compareTo(this.indexId, typedOther.indexId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_docId()).compareTo(typedOther.is_set_docId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_docId()) {
        lastComparison = TBaseHelper.compareTo(this.docId, typedOther.docId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_boosts()).compareTo(typedOther.is_set_boosts());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_boosts()) {
        lastComparison = TBaseHelper.compareTo(this.boosts, typedOther.boosts);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // INDEX_ID
            if (field.type == TType.STRING) {
              this.indexId = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // DOC_ID
            if (field.type == TType.STRING) {
              this.docId = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // BOOSTS
            if (field.type == TType.MAP) {
              {
                TMap _map150 = iprot.readMapBegin();
                this.boosts = new HashMap<Integer,Double>(2*_map150.size);
                for (int _i151 = 0; _i151 < _map150.size; ++_i151)
                {
                  int _key152;
                  double _val153;
                  _key152 = iprot.readI32();
                  _val153 = iprot.readDouble();
                  this.boosts.put(_key152, _val153);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.indexId != null) {
        oprot.writeFieldBegin(INDEX_ID_FIELD_DESC);
        oprot.writeString(this.indexId);
        oprot.writeFieldEnd();
      }
      if (this.docId != null) {
        oprot.writeFieldBegin(DOC_ID_FIELD_DESC);
        oprot.writeString(this.docId);
        oprot.writeFieldEnd();
      }
      if (this.boosts != null) {
        oprot.writeFieldBegin(BOOSTS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.I32, TType.DOUBLE, this.boosts.size()));
          for (Map.Entry<Integer, Double> _iter154 : this.boosts.entrySet())
          {
            oprot.writeI32(_iter154.getKey());
            oprot.writeDouble(_iter154.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enqueueUpdateBoosts_args(");
      boolean first = true;

      sb.append("indexId:");
      if (this.indexId == null) {
        sb.append("null");
      } else {
        sb.append(this.indexId);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("docId:");
      if (this.docId == null) {
        sb.append("null");
      } else {
        sb.append(this.docId);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("boosts:");
      if (this.boosts == null) {
        sb.append("null");
      } else {
        sb.append(this.boosts);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class enqueueUpdateBoosts_result implements TBase<enqueueUpdateBoosts_result, enqueueUpdateBoosts_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enqueueUpdateBoosts_result");

    private static final TField ITE_FIELD_DESC = new TField("ite", TType.STRUCT, (short)1);

    private IndextankException ite;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      ITE((short)1, "ite");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // ITE
            return ITE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.ITE, new FieldMetaData("ite", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enqueueUpdateBoosts_result.class, metaDataMap);
    }

    public enqueueUpdateBoosts_result() {
    }

    public enqueueUpdateBoosts_result(
      IndextankException ite)
    {
      this();
      this.ite = ite;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enqueueUpdateBoosts_result(enqueueUpdateBoosts_result other) {
      if (other.is_set_ite()) {
        this.ite = new IndextankException(other.ite);
      }
    }

    public enqueueUpdateBoosts_result deepCopy() {
      return new enqueueUpdateBoosts_result(this);
    }

    @Override
    public void clear() {
      this.ite = null;
    }

    public IndextankException get_ite() {
      return this.ite;
    }

    public enqueueUpdateBoosts_result set_ite(IndextankException ite) {
      this.ite = ite;
      return this;
    }

    public void unset_ite() {
      this.ite = null;
    }

    /** Returns true if field ite is set (has been asigned a value) and false otherwise */
    public boolean is_set_ite() {
      return this.ite != null;
    }

    public void set_ite_isSet(boolean value) {
      if (!value) {
        this.ite = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ITE:
        if (value == null) {
          unset_ite();
        } else {
          set_ite((IndextankException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ITE:
        return get_ite();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case ITE:
        return is_set_ite();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enqueueUpdateBoosts_result)
        return this.equals((enqueueUpdateBoosts_result)that);
      return false;
    }

    public boolean equals(enqueueUpdateBoosts_result that) {
      if (that == null)
        return false;

      boolean this_present_ite = true && this.is_set_ite();
      boolean that_present_ite = true && that.is_set_ite();
      if (this_present_ite || that_present_ite) {
        if (!(this_present_ite && that_present_ite))
          return false;
        if (!this.ite.equals(that.ite))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enqueueUpdateBoosts_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enqueueUpdateBoosts_result typedOther = (enqueueUpdateBoosts_result)other;

      lastComparison = Boolean.valueOf(is_set_ite()).compareTo(typedOther.is_set_ite());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_ite()) {
        lastComparison = TBaseHelper.compareTo(this.ite, typedOther.ite);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // ITE
            if (field.type == TType.STRUCT) {
              this.ite = new IndextankException();
              this.ite.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_ite()) {
        oprot.writeFieldBegin(ITE_FIELD_DESC);
        this.ite.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enqueueUpdateBoosts_result(");
      boolean first = true;

      sb.append("ite:");
      if (this.ite == null) {
        sb.append("null");
      } else {
        sb.append(this.ite);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class enqueueUpdateTimestamp_args implements TBase<enqueueUpdateTimestamp_args, enqueueUpdateTimestamp_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enqueueUpdateTimestamp_args");

    private static final TField INDEX_ID_FIELD_DESC = new TField("indexId", TType.STRING, (short)1);
    private static final TField DOC_ID_FIELD_DESC = new TField("docId", TType.STRING, (short)2);
    private static final TField TIMESTAMP_BOOST_FIELD_DESC = new TField("timestamp_boost", TType.I32, (short)3);

    private String indexId;
    private String docId;
    private int timestamp_boost;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      INDEX_ID((short)1, "indexId"),
      DOC_ID((short)2, "docId"),
      TIMESTAMP_BOOST((short)3, "timestamp_boost");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // INDEX_ID
            return INDEX_ID;
          case 2: // DOC_ID
            return DOC_ID;
          case 3: // TIMESTAMP_BOOST
            return TIMESTAMP_BOOST;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TIMESTAMP_BOOST_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.INDEX_ID, new FieldMetaData("indexId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DOC_ID, new FieldMetaData("docId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.TIMESTAMP_BOOST, new FieldMetaData("timestamp_boost", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enqueueUpdateTimestamp_args.class, metaDataMap);
    }

    public enqueueUpdateTimestamp_args() {
    }

    public enqueueUpdateTimestamp_args(
      String indexId,
      String docId,
      int timestamp_boost)
    {
      this();
      this.indexId = indexId;
      this.docId = docId;
      this.timestamp_boost = timestamp_boost;
      set_timestamp_boost_isSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enqueueUpdateTimestamp_args(enqueueUpdateTimestamp_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.is_set_indexId()) {
        this.indexId = other.indexId;
      }
      if (other.is_set_docId()) {
        this.docId = other.docId;
      }
      this.timestamp_boost = other.timestamp_boost;
    }

    public enqueueUpdateTimestamp_args deepCopy() {
      return new enqueueUpdateTimestamp_args(this);
    }

    @Override
    public void clear() {
      this.indexId = null;
      this.docId = null;
      set_timestamp_boost_isSet(false);
      this.timestamp_boost = 0;
    }

    public String get_indexId() {
      return this.indexId;
    }

    public enqueueUpdateTimestamp_args set_indexId(String indexId) {
      this.indexId = indexId;
      return this;
    }

    public void unset_indexId() {
      this.indexId = null;
    }

    /** Returns true if field indexId is set (has been asigned a value) and false otherwise */
    public boolean is_set_indexId() {
      return this.indexId != null;
    }

    public void set_indexId_isSet(boolean value) {
      if (!value) {
        this.indexId = null;
      }
    }

    public String get_docId() {
      return this.docId;
    }

    public enqueueUpdateTimestamp_args set_docId(String docId) {
      this.docId = docId;
      return this;
    }

    public void unset_docId() {
      this.docId = null;
    }

    /** Returns true if field docId is set (has been asigned a value) and false otherwise */
    public boolean is_set_docId() {
      return this.docId != null;
    }

    public void set_docId_isSet(boolean value) {
      if (!value) {
        this.docId = null;
      }
    }

    public int get_timestamp_boost() {
      return this.timestamp_boost;
    }

    public enqueueUpdateTimestamp_args set_timestamp_boost(int timestamp_boost) {
      this.timestamp_boost = timestamp_boost;
      set_timestamp_boost_isSet(true);
      return this;
    }

    public void unset_timestamp_boost() {
      __isset_bit_vector.clear(__TIMESTAMP_BOOST_ISSET_ID);
    }

    /** Returns true if field timestamp_boost is set (has been asigned a value) and false otherwise */
    public boolean is_set_timestamp_boost() {
      return __isset_bit_vector.get(__TIMESTAMP_BOOST_ISSET_ID);
    }

    public void set_timestamp_boost_isSet(boolean value) {
      __isset_bit_vector.set(__TIMESTAMP_BOOST_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case INDEX_ID:
        if (value == null) {
          unset_indexId();
        } else {
          set_indexId((String)value);
        }
        break;

      case DOC_ID:
        if (value == null) {
          unset_docId();
        } else {
          set_docId((String)value);
        }
        break;

      case TIMESTAMP_BOOST:
        if (value == null) {
          unset_timestamp_boost();
        } else {
          set_timestamp_boost((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case INDEX_ID:
        return get_indexId();

      case DOC_ID:
        return get_docId();

      case TIMESTAMP_BOOST:
        return new Integer(get_timestamp_boost());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case INDEX_ID:
        return is_set_indexId();
      case DOC_ID:
        return is_set_docId();
      case TIMESTAMP_BOOST:
        return is_set_timestamp_boost();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enqueueUpdateTimestamp_args)
        return this.equals((enqueueUpdateTimestamp_args)that);
      return false;
    }

    public boolean equals(enqueueUpdateTimestamp_args that) {
      if (that == null)
        return false;

      boolean this_present_indexId = true && this.is_set_indexId();
      boolean that_present_indexId = true && that.is_set_indexId();
      if (this_present_indexId || that_present_indexId) {
        if (!(this_present_indexId && that_present_indexId))
          return false;
        if (!this.indexId.equals(that.indexId))
          return false;
      }

      boolean this_present_docId = true && this.is_set_docId();
      boolean that_present_docId = true && that.is_set_docId();
      if (this_present_docId || that_present_docId) {
        if (!(this_present_docId && that_present_docId))
          return false;
        if (!this.docId.equals(that.docId))
          return false;
      }

      boolean this_present_timestamp_boost = true;
      boolean that_present_timestamp_boost = true;
      if (this_present_timestamp_boost || that_present_timestamp_boost) {
        if (!(this_present_timestamp_boost && that_present_timestamp_boost))
          return false;
        if (this.timestamp_boost != that.timestamp_boost)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enqueueUpdateTimestamp_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enqueueUpdateTimestamp_args typedOther = (enqueueUpdateTimestamp_args)other;

      lastComparison = Boolean.valueOf(is_set_indexId()).compareTo(typedOther.is_set_indexId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_indexId()) {
        lastComparison = TBaseHelper.compareTo(this.indexId, typedOther.indexId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_docId()).compareTo(typedOther.is_set_docId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_docId()) {
        lastComparison = TBaseHelper.compareTo(this.docId, typedOther.docId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_timestamp_boost()).compareTo(typedOther.is_set_timestamp_boost());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_timestamp_boost()) {
        lastComparison = TBaseHelper.compareTo(this.timestamp_boost, typedOther.timestamp_boost);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // INDEX_ID
            if (field.type == TType.STRING) {
              this.indexId = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // DOC_ID
            if (field.type == TType.STRING) {
              this.docId = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TIMESTAMP_BOOST
            if (field.type == TType.I32) {
              this.timestamp_boost = iprot.readI32();
              set_timestamp_boost_isSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.indexId != null) {
        oprot.writeFieldBegin(INDEX_ID_FIELD_DESC);
        oprot.writeString(this.indexId);
        oprot.writeFieldEnd();
      }
      if (this.docId != null) {
        oprot.writeFieldBegin(DOC_ID_FIELD_DESC);
        oprot.writeString(this.docId);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_BOOST_FIELD_DESC);
      oprot.writeI32(this.timestamp_boost);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enqueueUpdateTimestamp_args(");
      boolean first = true;

      sb.append("indexId:");
      if (this.indexId == null) {
        sb.append("null");
      } else {
        sb.append(this.indexId);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("docId:");
      if (this.docId == null) {
        sb.append("null");
      } else {
        sb.append(this.docId);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp_boost:");
      sb.append(this.timestamp_boost);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class enqueueUpdateTimestamp_result implements TBase<enqueueUpdateTimestamp_result, enqueueUpdateTimestamp_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enqueueUpdateTimestamp_result");

    private static final TField ITE_FIELD_DESC = new TField("ite", TType.STRUCT, (short)1);

    private IndextankException ite;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      ITE((short)1, "ite");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // ITE
            return ITE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.ITE, new FieldMetaData("ite", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enqueueUpdateTimestamp_result.class, metaDataMap);
    }

    public enqueueUpdateTimestamp_result() {
    }

    public enqueueUpdateTimestamp_result(
      IndextankException ite)
    {
      this();
      this.ite = ite;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enqueueUpdateTimestamp_result(enqueueUpdateTimestamp_result other) {
      if (other.is_set_ite()) {
        this.ite = new IndextankException(other.ite);
      }
    }

    public enqueueUpdateTimestamp_result deepCopy() {
      return new enqueueUpdateTimestamp_result(this);
    }

    @Override
    public void clear() {
      this.ite = null;
    }

    public IndextankException get_ite() {
      return this.ite;
    }

    public enqueueUpdateTimestamp_result set_ite(IndextankException ite) {
      this.ite = ite;
      return this;
    }

    public void unset_ite() {
      this.ite = null;
    }

    /** Returns true if field ite is set (has been asigned a value) and false otherwise */
    public boolean is_set_ite() {
      return this.ite != null;
    }

    public void set_ite_isSet(boolean value) {
      if (!value) {
        this.ite = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ITE:
        if (value == null) {
          unset_ite();
        } else {
          set_ite((IndextankException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ITE:
        return get_ite();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case ITE:
        return is_set_ite();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enqueueUpdateTimestamp_result)
        return this.equals((enqueueUpdateTimestamp_result)that);
      return false;
    }

    public boolean equals(enqueueUpdateTimestamp_result that) {
      if (that == null)
        return false;

      boolean this_present_ite = true && this.is_set_ite();
      boolean that_present_ite = true && that.is_set_ite();
      if (this_present_ite || that_present_ite) {
        if (!(this_present_ite && that_present_ite))
          return false;
        if (!this.ite.equals(that.ite))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enqueueUpdateTimestamp_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enqueueUpdateTimestamp_result typedOther = (enqueueUpdateTimestamp_result)other;

      lastComparison = Boolean.valueOf(is_set_ite()).compareTo(typedOther.is_set_ite());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_ite()) {
        lastComparison = TBaseHelper.compareTo(this.ite, typedOther.ite);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // ITE
            if (field.type == TType.STRUCT) {
              this.ite = new IndextankException();
              this.ite.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_ite()) {
        oprot.writeFieldBegin(ITE_FIELD_DESC);
        this.ite.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enqueueUpdateTimestamp_result(");
      boolean first = true;

      sb.append("ite:");
      if (this.ite == null) {
        sb.append("null");
      } else {
        sb.append(this.ite);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class enqueueUpdateCategories_args implements TBase<enqueueUpdateCategories_args, enqueueUpdateCategories_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enqueueUpdateCategories_args");

    private static final TField INDEX_ID_FIELD_DESC = new TField("indexId", TType.STRING, (short)1);
    private static final TField DOC_ID_FIELD_DESC = new TField("docId", TType.STRING, (short)2);
    private static final TField CATEGORIES_FIELD_DESC = new TField("categories", TType.MAP, (short)3);

    private String indexId;
    private String docId;
    private Map<String,String> categories;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      INDEX_ID((short)1, "indexId"),
      DOC_ID((short)2, "docId"),
      CATEGORIES((short)3, "categories");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // INDEX_ID
            return INDEX_ID;
          case 2: // DOC_ID
            return DOC_ID;
          case 3: // CATEGORIES
            return CATEGORIES;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.INDEX_ID, new FieldMetaData("indexId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DOC_ID, new FieldMetaData("docId", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.CATEGORIES, new FieldMetaData("categories", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enqueueUpdateCategories_args.class, metaDataMap);
    }

    public enqueueUpdateCategories_args() {
    }

    public enqueueUpdateCategories_args(
      String indexId,
      String docId,
      Map<String,String> categories)
    {
      this();
      this.indexId = indexId;
      this.docId = docId;
      this.categories = categories;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enqueueUpdateCategories_args(enqueueUpdateCategories_args other) {
      if (other.is_set_indexId()) {
        this.indexId = other.indexId;
      }
      if (other.is_set_docId()) {
        this.docId = other.docId;
      }
      if (other.is_set_categories()) {
        Map<String,String> __this__categories = new HashMap<String,String>();
        for (Map.Entry<String, String> other_element : other.categories.entrySet()) {

          String other_element_key = other_element.getKey();
          String other_element_value = other_element.getValue();

          String __this__categories_copy_key = other_element_key;

          String __this__categories_copy_value = other_element_value;

          __this__categories.put(__this__categories_copy_key, __this__categories_copy_value);
        }
        this.categories = __this__categories;
      }
    }

    public enqueueUpdateCategories_args deepCopy() {
      return new enqueueUpdateCategories_args(this);
    }

    @Override
    public void clear() {
      this.indexId = null;
      this.docId = null;
      this.categories = null;
    }

    public String get_indexId() {
      return this.indexId;
    }

    public enqueueUpdateCategories_args set_indexId(String indexId) {
      this.indexId = indexId;
      return this;
    }

    public void unset_indexId() {
      this.indexId = null;
    }

    /** Returns true if field indexId is set (has been asigned a value) and false otherwise */
    public boolean is_set_indexId() {
      return this.indexId != null;
    }

    public void set_indexId_isSet(boolean value) {
      if (!value) {
        this.indexId = null;
      }
    }

    public String get_docId() {
      return this.docId;
    }

    public enqueueUpdateCategories_args set_docId(String docId) {
      this.docId = docId;
      return this;
    }

    public void unset_docId() {
      this.docId = null;
    }

    /** Returns true if field docId is set (has been asigned a value) and false otherwise */
    public boolean is_set_docId() {
      return this.docId != null;
    }

    public void set_docId_isSet(boolean value) {
      if (!value) {
        this.docId = null;
      }
    }

    public int get_categories_size() {
      return (this.categories == null) ? 0 : this.categories.size();
    }

    public void put_to_categories(String key, String val) {
      if (this.categories == null) {
        this.categories = new HashMap<String,String>();
      }
      this.categories.put(key, val);
    }

    public Map<String,String> get_categories() {
      return this.categories;
    }

    public enqueueUpdateCategories_args set_categories(Map<String,String> categories) {
      this.categories = categories;
      return this;
    }

    public void unset_categories() {
      this.categories = null;
    }

    /** Returns true if field categories is set (has been asigned a value) and false otherwise */
    public boolean is_set_categories() {
      return this.categories != null;
    }

    public void set_categories_isSet(boolean value) {
      if (!value) {
        this.categories = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case INDEX_ID:
        if (value == null) {
          unset_indexId();
        } else {
          set_indexId((String)value);
        }
        break;

      case DOC_ID:
        if (value == null) {
          unset_docId();
        } else {
          set_docId((String)value);
        }
        break;

      case CATEGORIES:
        if (value == null) {
          unset_categories();
        } else {
          set_categories((Map<String,String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case INDEX_ID:
        return get_indexId();

      case DOC_ID:
        return get_docId();

      case CATEGORIES:
        return get_categories();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case INDEX_ID:
        return is_set_indexId();
      case DOC_ID:
        return is_set_docId();
      case CATEGORIES:
        return is_set_categories();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enqueueUpdateCategories_args)
        return this.equals((enqueueUpdateCategories_args)that);
      return false;
    }

    public boolean equals(enqueueUpdateCategories_args that) {
      if (that == null)
        return false;

      boolean this_present_indexId = true && this.is_set_indexId();
      boolean that_present_indexId = true && that.is_set_indexId();
      if (this_present_indexId || that_present_indexId) {
        if (!(this_present_indexId && that_present_indexId))
          return false;
        if (!this.indexId.equals(that.indexId))
          return false;
      }

      boolean this_present_docId = true && this.is_set_docId();
      boolean that_present_docId = true && that.is_set_docId();
      if (this_present_docId || that_present_docId) {
        if (!(this_present_docId && that_present_docId))
          return false;
        if (!this.docId.equals(that.docId))
          return false;
      }

      boolean this_present_categories = true && this.is_set_categories();
      boolean that_present_categories = true && that.is_set_categories();
      if (this_present_categories || that_present_categories) {
        if (!(this_present_categories && that_present_categories))
          return false;
        if (!this.categories.equals(that.categories))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enqueueUpdateCategories_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enqueueUpdateCategories_args typedOther = (enqueueUpdateCategories_args)other;

      lastComparison = Boolean.valueOf(is_set_indexId()).compareTo(typedOther.is_set_indexId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_indexId()) {
        lastComparison = TBaseHelper.compareTo(this.indexId, typedOther.indexId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_docId()).compareTo(typedOther.is_set_docId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_docId()) {
        lastComparison = TBaseHelper.compareTo(this.docId, typedOther.docId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_categories()).compareTo(typedOther.is_set_categories());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_categories()) {
        lastComparison = TBaseHelper.compareTo(this.categories, typedOther.categories);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // INDEX_ID
            if (field.type == TType.STRING) {
              this.indexId = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // DOC_ID
            if (field.type == TType.STRING) {
              this.docId = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // CATEGORIES
            if (field.type == TType.MAP) {
              {
                TMap _map155 = iprot.readMapBegin();
                this.categories = new HashMap<String,String>(2*_map155.size);
                for (int _i156 = 0; _i156 < _map155.size; ++_i156)
                {
                  String _key157;
                  String _val158;
                  _key157 = iprot.readString();
                  _val158 = iprot.readString();
                  this.categories.put(_key157, _val158);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.indexId != null) {
        oprot.writeFieldBegin(INDEX_ID_FIELD_DESC);
        oprot.writeString(this.indexId);
        oprot.writeFieldEnd();
      }
      if (this.docId != null) {
        oprot.writeFieldBegin(DOC_ID_FIELD_DESC);
        oprot.writeString(this.docId);
        oprot.writeFieldEnd();
      }
      if (this.categories != null) {
        oprot.writeFieldBegin(CATEGORIES_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.categories.size()));
          for (Map.Entry<String, String> _iter159 : this.categories.entrySet())
          {
            oprot.writeString(_iter159.getKey());
            oprot.writeString(_iter159.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enqueueUpdateCategories_args(");
      boolean first = true;

      sb.append("indexId:");
      if (this.indexId == null) {
        sb.append("null");
      } else {
        sb.append(this.indexId);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("docId:");
      if (this.docId == null) {
        sb.append("null");
      } else {
        sb.append(this.docId);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("categories:");
      if (this.categories == null) {
        sb.append("null");
      } else {
        sb.append(this.categories);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class enqueueUpdateCategories_result implements TBase<enqueueUpdateCategories_result, enqueueUpdateCategories_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enqueueUpdateCategories_result");

    private static final TField ITE_FIELD_DESC = new TField("ite", TType.STRUCT, (short)1);

    private IndextankException ite;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      ITE((short)1, "ite");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // ITE
            return ITE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.ITE, new FieldMetaData("ite", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(enqueueUpdateCategories_result.class, metaDataMap);
    }

    public enqueueUpdateCategories_result() {
    }

    public enqueueUpdateCategories_result(
      IndextankException ite)
    {
      this();
      this.ite = ite;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enqueueUpdateCategories_result(enqueueUpdateCategories_result other) {
      if (other.is_set_ite()) {
        this.ite = new IndextankException(other.ite);
      }
    }

    public enqueueUpdateCategories_result deepCopy() {
      return new enqueueUpdateCategories_result(this);
    }

    @Override
    public void clear() {
      this.ite = null;
    }

    public IndextankException get_ite() {
      return this.ite;
    }

    public enqueueUpdateCategories_result set_ite(IndextankException ite) {
      this.ite = ite;
      return this;
    }

    public void unset_ite() {
      this.ite = null;
    }

    /** Returns true if field ite is set (has been asigned a value) and false otherwise */
    public boolean is_set_ite() {
      return this.ite != null;
    }

    public void set_ite_isSet(boolean value) {
      if (!value) {
        this.ite = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ITE:
        if (value == null) {
          unset_ite();
        } else {
          set_ite((IndextankException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ITE:
        return get_ite();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case ITE:
        return is_set_ite();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enqueueUpdateCategories_result)
        return this.equals((enqueueUpdateCategories_result)that);
      return false;
    }

    public boolean equals(enqueueUpdateCategories_result that) {
      if (that == null)
        return false;

      boolean this_present_ite = true && this.is_set_ite();
      boolean that_present_ite = true && that.is_set_ite();
      if (this_present_ite || that_present_ite) {
        if (!(this_present_ite && that_present_ite))
          return false;
        if (!this.ite.equals(that.ite))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enqueueUpdateCategories_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enqueueUpdateCategories_result typedOther = (enqueueUpdateCategories_result)other;

      lastComparison = Boolean.valueOf(is_set_ite()).compareTo(typedOther.is_set_ite());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_ite()) {
        lastComparison = TBaseHelper.compareTo(this.ite, typedOther.ite);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // ITE
            if (field.type == TType.STRUCT) {
              this.ite = new IndextankException();
              this.ite.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_ite()) {
        oprot.writeFieldBegin(ITE_FIELD_DESC);
        this.ite.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enqueueUpdateCategories_result(");
      boolean first = true;

      sb.append("ite:");
      if (this.ite == null) {
        sb.append("null");
      } else {
        sb.append(this.ite);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class sendAdminCommand_args implements TBase<sendAdminCommand_args, sendAdminCommand_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("sendAdminCommand_args");

    private static final TField COMMAND_FIELD_DESC = new TField("command", TType.STRING, (short)1);
    private static final TField INFO_FIELD_DESC = new TField("info", TType.MAP, (short)2);

    private String command;
    private Map<String,String> info;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      COMMAND((short)1, "command"),
      INFO((short)2, "info");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // COMMAND
            return COMMAND;
          case 2: // INFO
            return INFO;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.COMMAND, new FieldMetaData("command", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.INFO, new FieldMetaData("info", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.STRING), 
              new FieldValueMetaData(TType.STRING))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(sendAdminCommand_args.class, metaDataMap);
    }

    public sendAdminCommand_args() {
      this.info = new HashMap<String,String>();

    }

    public sendAdminCommand_args(
      String command,
      Map<String,String> info)
    {
      this();
      this.command = command;
      this.info = info;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public sendAdminCommand_args(sendAdminCommand_args other) {
      if (other.is_set_command()) {
        this.command = other.command;
      }
      if (other.is_set_info()) {
        Map<String,String> __this__info = new HashMap<String,String>();
        for (Map.Entry<String, String> other_element : other.info.entrySet()) {

          String other_element_key = other_element.getKey();
          String other_element_value = other_element.getValue();

          String __this__info_copy_key = other_element_key;

          String __this__info_copy_value = other_element_value;

          __this__info.put(__this__info_copy_key, __this__info_copy_value);
        }
        this.info = __this__info;
      }
    }

    public sendAdminCommand_args deepCopy() {
      return new sendAdminCommand_args(this);
    }

    @Override
    public void clear() {
      this.command = null;
      this.info = new HashMap<String,String>();

    }

    public String get_command() {
      return this.command;
    }

    public sendAdminCommand_args set_command(String command) {
      this.command = command;
      return this;
    }

    public void unset_command() {
      this.command = null;
    }

    /** Returns true if field command is set (has been asigned a value) and false otherwise */
    public boolean is_set_command() {
      return this.command != null;
    }

    public void set_command_isSet(boolean value) {
      if (!value) {
        this.command = null;
      }
    }

    public int get_info_size() {
      return (this.info == null) ? 0 : this.info.size();
    }

    public void put_to_info(String key, String val) {
      if (this.info == null) {
        this.info = new HashMap<String,String>();
      }
      this.info.put(key, val);
    }

    public Map<String,String> get_info() {
      return this.info;
    }

    public sendAdminCommand_args set_info(Map<String,String> info) {
      this.info = info;
      return this;
    }

    public void unset_info() {
      this.info = null;
    }

    /** Returns true if field info is set (has been asigned a value) and false otherwise */
    public boolean is_set_info() {
      return this.info != null;
    }

    public void set_info_isSet(boolean value) {
      if (!value) {
        this.info = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case COMMAND:
        if (value == null) {
          unset_command();
        } else {
          set_command((String)value);
        }
        break;

      case INFO:
        if (value == null) {
          unset_info();
        } else {
          set_info((Map<String,String>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case COMMAND:
        return get_command();

      case INFO:
        return get_info();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case COMMAND:
        return is_set_command();
      case INFO:
        return is_set_info();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof sendAdminCommand_args)
        return this.equals((sendAdminCommand_args)that);
      return false;
    }

    public boolean equals(sendAdminCommand_args that) {
      if (that == null)
        return false;

      boolean this_present_command = true && this.is_set_command();
      boolean that_present_command = true && that.is_set_command();
      if (this_present_command || that_present_command) {
        if (!(this_present_command && that_present_command))
          return false;
        if (!this.command.equals(that.command))
          return false;
      }

      boolean this_present_info = true && this.is_set_info();
      boolean that_present_info = true && that.is_set_info();
      if (this_present_info || that_present_info) {
        if (!(this_present_info && that_present_info))
          return false;
        if (!this.info.equals(that.info))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(sendAdminCommand_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      sendAdminCommand_args typedOther = (sendAdminCommand_args)other;

      lastComparison = Boolean.valueOf(is_set_command()).compareTo(typedOther.is_set_command());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_command()) {
        lastComparison = TBaseHelper.compareTo(this.command, typedOther.command);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_info()).compareTo(typedOther.is_set_info());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_info()) {
        lastComparison = TBaseHelper.compareTo(this.info, typedOther.info);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // COMMAND
            if (field.type == TType.STRING) {
              this.command = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // INFO
            if (field.type == TType.MAP) {
              {
                TMap _map160 = iprot.readMapBegin();
                this.info = new HashMap<String,String>(2*_map160.size);
                for (int _i161 = 0; _i161 < _map160.size; ++_i161)
                {
                  String _key162;
                  String _val163;
                  _key162 = iprot.readString();
                  _val163 = iprot.readString();
                  this.info.put(_key162, _val163);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.command != null) {
        oprot.writeFieldBegin(COMMAND_FIELD_DESC);
        oprot.writeString(this.command);
        oprot.writeFieldEnd();
      }
      if (this.info != null) {
        oprot.writeFieldBegin(INFO_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.info.size()));
          for (Map.Entry<String, String> _iter164 : this.info.entrySet())
          {
            oprot.writeString(_iter164.getKey());
            oprot.writeString(_iter164.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("sendAdminCommand_args(");
      boolean first = true;

      sb.append("command:");
      if (this.command == null) {
        sb.append("null");
      } else {
        sb.append(this.command);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("info:");
      if (this.info == null) {
        sb.append("null");
      } else {
        sb.append(this.info);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class sendAdminCommand_result implements TBase<sendAdminCommand_result, sendAdminCommand_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("sendAdminCommand_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField ITE_FIELD_DESC = new TField("ite", TType.STRUCT, (short)1);

    private String success;
    private IndextankException ite;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      ITE((short)1, "ite");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // ITE
            return ITE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.ITE, new FieldMetaData("ite", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(sendAdminCommand_result.class, metaDataMap);
    }

    public sendAdminCommand_result() {
    }

    public sendAdminCommand_result(
      String success,
      IndextankException ite)
    {
      this();
      this.success = success;
      this.ite = ite;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public sendAdminCommand_result(sendAdminCommand_result other) {
      if (other.is_set_success()) {
        this.success = other.success;
      }
      if (other.is_set_ite()) {
        this.ite = new IndextankException(other.ite);
      }
    }

    public sendAdminCommand_result deepCopy() {
      return new sendAdminCommand_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.ite = null;
    }

    public String get_success() {
      return this.success;
    }

    public sendAdminCommand_result set_success(String success) {
      this.success = success;
      return this;
    }

    public void unset_success() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean is_set_success() {
      return this.success != null;
    }

    public void set_success_isSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IndextankException get_ite() {
      return this.ite;
    }

    public sendAdminCommand_result set_ite(IndextankException ite) {
      this.ite = ite;
      return this;
    }

    public void unset_ite() {
      this.ite = null;
    }

    /** Returns true if field ite is set (has been asigned a value) and false otherwise */
    public boolean is_set_ite() {
      return this.ite != null;
    }

    public void set_ite_isSet(boolean value) {
      if (!value) {
        this.ite = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unset_success();
        } else {
          set_success((String)value);
        }
        break;

      case ITE:
        if (value == null) {
          unset_ite();
        } else {
          set_ite((IndextankException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return get_success();

      case ITE:
        return get_ite();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return is_set_success();
      case ITE:
        return is_set_ite();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof sendAdminCommand_result)
        return this.equals((sendAdminCommand_result)that);
      return false;
    }

    public boolean equals(sendAdminCommand_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.is_set_success();
      boolean that_present_success = true && that.is_set_success();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ite = true && this.is_set_ite();
      boolean that_present_ite = true && that.is_set_ite();
      if (this_present_ite || that_present_ite) {
        if (!(this_present_ite && that_present_ite))
          return false;
        if (!this.ite.equals(that.ite))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(sendAdminCommand_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      sendAdminCommand_result typedOther = (sendAdminCommand_result)other;

      lastComparison = Boolean.valueOf(is_set_success()).compareTo(typedOther.is_set_success());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_success()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(is_set_ite()).compareTo(typedOther.is_set_ite());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (is_set_ite()) {
        lastComparison = TBaseHelper.compareTo(this.ite, typedOther.ite);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // ITE
            if (field.type == TType.STRUCT) {
              this.ite = new IndextankException();
              this.ite.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.is_set_success()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      } else if (this.is_set_ite()) {
        oprot.writeFieldBegin(ITE_FIELD_DESC);
        this.ite.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("sendAdminCommand_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ite:");
      if (this.ite == null) {
        sb.append("null");
      } else {
        sb.append(this.ite);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
